import csv
from typing import Tuple

import numpy as np
from pandas import read_csv

from .loader import Loader
from ..common import *
from ..errors import InvalidDataError


class BlackboxLogViewerCsvLoader(Loader):
    """Loads CSV data generated by Blackbox Log Viewer.
    """

    # keycheck for 'usecols' only reads usefull traces, uncomment if needed
    CSV_FIELDS = ['time',
                  'rcCommand[0]', 'rcCommand[1]', 'rcCommand[2]', 'rcCommand[3]',
                  'axisP[0]', 'axisP[1]', 'axisP[2]',
                  'axisI[0]', 'axisI[1]', 'axisI[2]',
                  'axisD[0]', 'axisD[1]', 'axisD[2]',
                  'gyroADC[0]', 'gyroADC[1]', 'gyroADC[2]',
                  'gyroData[0]', 'gyroData[1]', 'gyroData[2]',
                  'ugyroADC[0]', 'ugyroADC[1]', 'ugyroADC[2]',
                  'debug[0]', 'debug[1]', 'debug[2]', 'debug[3]',
                  ]

    TIME_FIELD = "time"

    @staticmethod
    def is_applicable(path: str) -> bool:
        if ".csv" != os.path.splitext(path)[1].lower():
            return False
        with open(path) as f:
            for row in csv.reader(f):
                if len(row) == 2:
                    # CSV begins with two columns per row, assume those being header fields
                    return True
                return False
        return False

    def _read_headers(self, path: str) -> Tuple[dict]:
        _, ext = os.path.splitext(path)
        tmp_csv_name = os.path.basename(path).replace(ext, ".main.csv")
        tmp_csv_path = os.path.join(self.tmp_path, tmp_csv_name)
        headers = headerdict(tmp_csv_path)
        main_fields_start_row = None
        with open(path) as f:
            lines = f.readlines()
            for line_num, line in enumerate(lines):
                if CSV_HEADER_ROW_FRAGMENT in line:
                    main_fields_start_row = line_num
                    break
            if main_fields_start_row is None:
                raise InvalidDataError(path, message="Data frames not found")
            with open(tmp_csv_path, 'w') as tmpf:
                tmpf.writelines(lines[main_fields_start_row:])
        # check for known keys and translate to useful ones.
        for line in lines[:main_fields_start_row]:
            for key in FIELDS_MAP.keys():
                if key in line:
                    val = strip_quotes(line.split(',', 1)[1])
                    headers.update({FIELDS_MAP[key]: val})
        return tuple(headers)

    def _read_data(self, path: str) -> Tuple[dict]:
        data = read_csv(path, header=0, skipinitialspace=1, usecols=lambda k: k in self.CSV_FIELDS, dtype=np.float64)

        result = {}
        result.update({'throttle': data['rcCommand[3]'].values, 'time_us': data[self.TIME_FIELD].values * 1e-6})
        for i in ['0', '1', '2']:
            result.update({'rcCommand' + i: data['rcCommand[' + i + ']'].values})
            try:
                result.update({'debug' + i: data['debug[' + i + ']'].values})
            except KeyError:
                log.warning('No debug[' + i + '] trace found!')
                result.update({'debug' + i: np.zeros_like(data['rcCommand[' + i + ']'].values)})

            try:
                result.update({'PID loop in' + i: data['axisP[' + i + ']'].values})
            except KeyError:
                log.warning('No P[' + i + '] trace found!')
                result.update({'PID loop in' + i: np.zeros_like(data['rcCommand[' + i + ']'].values)})

            try:
                result.update({'d_err' + i: data['axisD[' + i + ']'].values})
            except KeyError:
                log.warning('No D[' + i + '] trace found!')
                result.update({'d_err' + i: np.zeros_like(data['rcCommand[' + i + ']'].values)})

            try:
                result.update({'I_term' + i: data['axisI[' + i + ']'].values})
            except KeyError:
                if i < 2:
                    log.warning('No I[' + i + '] trace found!')
                result.update({'I_term' + i: np.zeros_like(data['rcCommand[' + i + ']'].values)})

            result.update({'PID sum' + i: result['PID loop in' + i] + result['I_term' + i] + result['d_err' + i]})
            if 'gyroADC[0]' in data.keys():
                result.update({'gyroData' + i: data['gyroADC[' + i + ']'].values})
            elif 'gyroData[0]' in data.keys():
                result.update({'gyroData' + i: data['gyroData[' + i + ']'].values})
            elif 'ugyroADC[0]' in data.keys():
                result.update({'gyroData' + i: data['ugyroADC[' + i + ']'].values})
            else:
                log.warning('No gyro trace found!')
        return tuple((result,))
